<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="2122" status="Open">
<title><tt>merge()</tt> stability for lists versus forward lists</title>
<section><sref ref="[list.ops]"/>, <sref ref="[forwardlist.ops]"/></section>
<submitter>Nicolai Josuttis</submitter>
<date>15 Jan 2012</date>

<discussion>

<p>
<tt>forward_list::merge()</tt> is specified in  <sref ref="[forwardlist.ops]"/>, p19 as follows:
</p>
<blockquote><p>
This operation shall be stable: for equivalent elements in the two lists,
the elements from <tt>*this</tt> shall always precede the elements from <tt>x</tt>.
</p></blockquote>
<p>
But <tt>list::merge()</tt> is only specified in <sref ref="[list.ops]"/>, p24 as follows:
</p>
<blockquote><p>
<i>Remarks</i>: Stable.
</p></blockquote>
<p>
Note that in general we define "stable" only for algorithms (see <sref ref="[defns.stable]"/> and 
<sref ref="[algorithm.stable]"/>) so for member function we should explain it everywhere we use it.
<p/>
Thus for lists we have to add:
</p>
<blockquote><p>
Stable: for equivalent elements in the two lists, the elements from the list always precede the elements
from the argument list.
</p></blockquote>
<p>
This, BTW, was the specification we had with C++03.
<p/>
In addition, I wonder whether we also have some guarantees regarding stability saying that the order 
of equivalent elements of each list merged remains stable (which would be my interpretation of just 
saying "stable", BTW).
<p/>
Thus, I'd expect that for equivalent elements we guarantee that
</p>
<ul>
 <li> we first have all element of <tt>*this</tt> (in the same order as on entry)</li>
 <li> and then all elements of the passed argument (in the same order as on entry).</li>
</ul>


<note>2012, Kona</note>
<p>
Move to Open.
</p>
<p>
STL says we need to fix up 17.6.5.7 to be stronger, and then the remarks for merge should
just say "Remarks: Stable (see 17.6.5.7)"
</p>
<p>
Assigned to STL for word-smithing.
</p>

</discussion>

<resolution>
<p>This wording is relative to the FDIS.</p>

<ol>
<li>
<p>Change <sref ref="[list.ops]"/> as indicated:</p>

<blockquote><pre>
void                          merge(list&lt;T,Allocator&gt;&amp; x);
void                          merge(list&lt;T,Allocator&gt;&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&lt;T,Allocator&gt;&amp; x, Compare comp);
template &lt;class Compare&gt; void merge(list&lt;T,Allocator&gt;&amp;&amp; x, Compare comp);</pre>
<blockquote><p>
[&hellip;]
<p/>
-24- <i>Remarks</i>: <del>Stable</del><ins>This operation shall be stable: for equivalent elements 
in the two lists, the elements from <tt>*this</tt> shall always precede the elements from <tt>x</tt>
and the order of equivalent elements of <tt>*this</tt> and <tt>x</tt> remains stable</ins>. If 
<tt>(&amp;x != this)</tt> the range <tt>[x.begin(), x.end())</tt> 
is empty after the merge. No elements are copied by this operation. The behavior is undefined if 
<tt>this-&gt;get_allocator() != x.get_allocator()</tt>.
</p></blockquote></blockquote>
</li>

<li>
<p>Change <sref ref="[forwardlist.ops]"/> as indicated:</p>

<blockquote><pre>
void merge(forward_list&lt;T,Allocator&gt;&amp; x);
void merge(forward_list&lt;T,Allocator&gt;&amp;&amp; x);
template &lt;class Compare&gt; void merge(forward_list&lt;T,Allocator&gt;&amp; x, Compare comp);
template &lt;class Compare&gt; void merge(forward_list&lt;T,Allocator&gt;&amp;&amp; x, Compare comp);</pre>
<blockquote><p>
[&hellip;]
<p/>
-19- <i>Effects</i>: Merges <tt>x</tt> into <tt>*this</tt>. This operation shall be stable: for 
equivalent elements in the two lists, the elements from <tt>*this</tt> shall always precede the 
elements from <tt>x</tt> <ins>and the order of equivalent elements of <tt>*this</tt> and <tt>x</tt> 
remains stable</ins>. <tt>x</tt> is empty after the merge. If an exception is thrown other 
than by a comparison there are no effects. Pointers and references to the moved elements of <tt>x</tt> 
now refer to those same elements but as members of <tt>*this</tt>. Iterators referring
to the moved elements will continue to refer to their elements, but they now behave as iterators into
<tt>*this</tt>, not into <tt>x</tt>.
</p></blockquote></blockquote>
</li>
</ol>

</resolution>

</issue>
