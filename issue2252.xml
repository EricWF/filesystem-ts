<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="2252" status="New">
<title>Strong guarantee on <tt>vector::push_back()</tt> still broken with C++11?</title>
<section><sref ref="[vector.modifiers]"/></section>
<submitter>Nicolai Josuttis</submitter>
<date>21 Apr 2013</date>

<discussion>

<p>
According to my understanding, the strong guarantee of <tt>push_back()</tt> led to the introduction of <tt>noexcept</tt> 
and to the typical implementation that vectors usually copy their elements on reallocation unless the move operations of 
their element type guarantees not to throw.
<p/>
However, if I read the standard correctly, we still don't give the strong guarantee any more:
Yes, <sref ref="[container.requirements.general]"/>/10 specifies:
</p>
<blockquote>
<p>
Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.3.4, and 23.3.6.5) all container types defined in this
Clause meet the following additional requirements:
</p>
<ul>
<li>[&hellip;]</li>
<li>if an exception is thrown by a <tt>push_back()</tt> or <tt>push_front()</tt> function, that function has no effects.</li>
</ul>
</blockquote>
<p>
However, <sref ref="[vector.modifiers]"/> specifies for vector modifiers, <em>including</em> <tt>push_back()</tt>:
</p>
<blockquote>
<p>
If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move 
assignment operator of <tt>T</tt> or by any <tt>InputIterator</tt> operation there are no effects. If an exception 
is thrown by the move constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt>, the effects are unspecified.
</p>
</blockquote>
<p>
I would interpret this as an "otherwise specified" behavior for <tt>push_back()</tt>, saying that the strong guarantee 
is only given if constructors and assignments do not throw. 
<p/>
That means, the strong guarantee of C++03 is broken with C++11.
<p/>
In addition to all that <sref ref="[container.requirements.general]"/> p10 b2 doesn't mention the corresponding functions
<tt>emplace_back()</tt> and <tt>emplace_front()</tt>. These are similar single-element additions and should provide the same
strong guarantee.
<p/>
Daniel adds:
<p/>
It seems the error came in when <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf">N2350</a>
and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2345.pdf">N2345</a> became accepted and where 
integrated into the working draft <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2369.pdf">N2369</a>.
The merge resulted in a form that changed the previous meaning and as far as I understand it, this effect was not intended.
</p>

<note>2013-09-16, Nico provides concrete wording</note>

</discussion>

<resolution>

<p>This wording is relative to N3691.</p>

<ol>
<li><p>Edit <sref ref="[container.requirements.general]"/> p10 b2 as indicated:</p>

<ul>
<li>[&hellip;]</li>
<li><p>
if an exception is thrown by a <tt>push_back()</tt><ins>, <tt>push_front()</tt>, <tt>emplace_back()</tt>,</ins> or 
<tt><del>push</del><ins>emplace</ins>_front()</tt> function <ins>and the element type is <tt>CopyInsertable</tt> or 
has a non-throwing move constructor</ins>, that function has no effects.
</p></li>
</ul>

</li>

<li><p>Edit <sref ref="[deque.modifiers]"/> as indicated:</p>

<blockquote>
<pre>
<ins>void push_front(const T&amp; x);
void push_front(T&amp;&amp; x);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
template &lt;class... Args&gt; void emplace_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Invalidates all the iterators to the deque, but has no effect on the validity of references 
to elements of the deque.</ins> 
<p/>
<ins>-?- <i>Remarks:</i> If an exception is thrown and the element type is <tt>CopyInsertable</tt> or has a non-throwing move constructor
there are no effects.</ins> 
<p/>
<ins>-?- <i>Complexity:</i> Always takes constant time and causes a single call to a constructor of <tt>T</tt>.</ins> 
</p>
</blockquote>
<pre>
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
iterator insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator>
  iterator insert(const_iterator position,
                  InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list&lt;T&gt;);

<del>template &lt;class... Args&gt; void emplace_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);</del>
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
<del>void push_front(const T&amp; x);
void push_front(T&amp;&amp; x);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);</del>
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> An insertion in the middle of the deque invalidates all the iterators and references to elements
of the deque. An insertion at either end of the deque invalidates all the iterators to the deque, but has
no effect on the validity of references to elements of the deque.
<p/>
-2- <i>Remarks:</i> If an exception is thrown other than by the copy constructor, move constructor, assignment
operator, or move assignment operator of <tt>T</tt> there are no effects. If an exception is thrown by the move
constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt>, the effects are unspecified.
<p/>
-3- <i>Complexity:</i> The complexity is linear in the number of elements inserted plus the lesser of the distances
to the beginning and end of the deque. Inserting a single element either at the beginning or end of a
deque always takes constant time and causes a single call to a constructor of <tt>T</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit <sref ref="[vector.modifiers]"/> as indicated:</p>

<blockquote>
<pre>
<ins>void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> Causes reallocation if the new size is greater than the old capacity. If no reallocation happens,
all the iterators and references before the insertion point remain valid. If an exception is thrown and the element type is 
<tt>CopyInsertable</tt> or has a non-throwing move constructor there are no effects.</ins> 
<p/>
<ins>-?- <i>Complexity:</i> The complexity is amortized constant.</ins> 
</p>
</blockquote>
<pre>
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
iterator insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator>
  iterator insert(const_iterator position, InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list&lt;T&gt;);

<del>template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);</del>
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
<del>void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);</del>
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> Causes reallocation if the new size is greater than the old capacity. If no reallocation happens,
all the iterators and references before the insertion point remain valid. If an exception is thrown other
than by the copy constructor, move constructor, assignment operator, or move assignment operator
of <tt>T</tt> or by any <tt>InputIterator</tt> operation there are no effects. If an exception is thrown by the move
constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt>, the effects are unspecified.
<p/>
-2- <i>Complexity:</i> The complexity is linear in the number of elements inserted plus the distance to the end
of the vector.
</p>
</blockquote>
</blockquote>
</li>
</ol>

</resolution>

</issue>
