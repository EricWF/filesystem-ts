<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [
  <!ENTITY nbsp "&#160;">
] >

<issue num="1448" status="Open">
<title>[FCD] Concerns about <tt>basic_stringbuf::str(basic_string)</tt> postconditions</title>
<section><sref ref="[stringbuf.members]"/></section>
<submitter>BSI</submitter>
<date>25 Aug 2010</date>

<discussion>
<p><b>Addresses GB-124</b></p>

<p>
N3092 <sref ref="[stringbuf.members]"/> contains this textcspecifying the postconditions of
<tt>basic_stringbuf::str(basic_string)</tt>:
</p>
<blockquote>
Postconditions: If <tt>mode &amp; ios_base::out</tt> is <tt>true</tt>,
<tt>pbase()</tt> points to the first underlying character and <tt>epptr() >=
pbase() + s.size()</tt> holds; in addition, if <tt>mode &amp; ios_base::in</tt>
is <tt>true</tt>, <tt>pptr() == pbase() + s.data()</tt> holds, otherwise
<tt>pptr() == pbase()</tt> is <tt>true</tt>. [...]
</blockquote>
<p>
Firstly, there's a simple mistake: It should be <tt>pbase() + s.length()</tt>,
not <tt>pbase() + s.data()</tt>.
</p>
<p>
Secondly, it doesn't match existing implementations. As far as I can tell,
GCC 4.5 does not test for <tt>mode &amp; ios_base::in</tt> in the second part
of that sentence, but for <tt>mode &amp; (ios_base::app | ios_base_ate)</tt>,
and Visual C++ 9 for <tt>mode &amp; ios_base::app</tt>. Besides, the wording of
the C++0x draft doesn't make any sense to me. I suggest changing the second part
of the sentence to one of the following:
</p>
<p>
Replace <tt>ios_base::in</tt> with <tt>(ios_base::ate | ios_base::app)</tt>,
but this would require Visual C++ to change (replacing only with
<tt>ios_base::ate</tt> would require GCC to change, and would make
<tt>ios_base::app</tt> completely useless with <tt>stringstreams</tt>):
</p>
<p>
in addition, if <tt>mode &amp; (ios_base::ate | ios_base::app)</tt> is <tt>true</tt>,
<tt>pptr() == pbase() + s.length()</tt> holds, otherwise <tt>pptr() == pbase()</tt>
is <tt>true</tt>.
</p>
<p>
Leave <tt>pptr()</tt> unspecified if <tt>mode &amp; ios_base::app</tt>, but not
<tt>mode &amp; ios_base::ate</tt> (implementations already differ in this case, and it
is always possible to use <tt>ios_base::ate</tt> to get the effect of appending, so it
is not necessary to require any implementation to change):
</p>
<p>
in addition, if <tt>mode &amp; ios_base::ate</tt> is <tt>true</tt>,
<tt>pptr() == pbase() + s.length()</tt> holds, if neither <tt>mode &amp; ios_base::ate</tt>
nor <tt>mode &amp; ios_base::app</tt> is <tt>true</tt>, <tt>pptr() == pbase()</tt> holds,
otherwise <tt>pptr() >= pbase() &amp;&amp; pptr() &lt;= pbase() + s.length()</tt>
(which of the values in this range is unspecified).
</p>
<p>
Slightly stricter:
</p>
<p>
in addition, if <tt>mode &amp; ios_base::ate</tt> is <tt>true</tt>,
<tt>pptr() == pbase() + s.length()</tt> holds, if neither
<tt>mode &amp; ios_base::ate</tt> nor <tt>mode &amp; ios_base::app</tt> is <tt>true</tt>,
<tt>pptr() == pbase()</tt> holds, otherwise <tt>pptr() == pbase() || pptr() == pbase() + s.length()</tt>
(which of these two values is unspecified). A small table might help to better explain the three cases.
BTW, at the end of the postconditions is this text: &quot;<tt>egptr() == eback() + s.size()</tt> hold&quot;.
Is there a perference for <tt>basic_string::length</tt> or <tt>basic_string::size</tt>? It doesn't really
matter, but it looks a bit inconsistent.
</p>
</discussion>

<resolution>
</resolution>

</issue>
