<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="1335" status="New">
<title>Insufficient requirements for <tt>tuple::operator&lt;()</tt></title>
<section><sref ref="[tuple.rel]"/></section>
<submitter>Joe Gottman</submitter>
<date>15 May 2010</date>

<discussion>
<p>
The requirements section for <tt>std::tuple</tt> says the following: 
</p>

<blockquote>
<i>Requires:</i> For all <tt>i</tt>, where <tt>0 &lt;= i and i &lt;
sizeof...(Types)</tt>, <tt>get&lt;i&gt;(t) &lt; get&lt;i&gt;(u)</tt> is a valid
expression returning a type that is convertible to <tt>bool</tt>.
<tt>sizeof...(TTypes) == sizeof...(UTypes)</tt>.
</blockquote>

<p>
This is necessary but not sufficient, as the algorithm for comparing
<tt>tuple</tt>s also computes <tt>get&lt;i&gt;(u) &lt; get&lt;i&gt;(t)</tt>
(note the order)
</p>

</discussion>

<resolution>
<p>
Change <sref ref="[tuple.rel]"/> to say
</p>

<blockquote><pre>
template&lt;class... TTypes, class... UTypes&gt;
  bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<i>Requires:</i> For all <tt>i</tt>, where <tt>0 &lt;= i and i &lt;
sizeof...(Types)</tt>, <tt>get&lt;i&gt;(t) &lt; get&lt;i&gt;(u)</tt> <ins>and
<tt>get&lt;i&gt;(u) &lt; get&lt;i&gt;(t)</tt> are</ins> <del>is a</del> valid
expressions returning types that are convertible to <tt>bool</tt>.
<tt>sizeof...(TTypes) == sizeof...(UTypes)</tt>.
</blockquote>
</blockquote>

</resolution>

</issue>
