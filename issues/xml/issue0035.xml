<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="35" status="New">
<title>[PDTS] <tt>directory_options::skip_permission_denied</tt> is not used</title>
<section><sref ref="6 [fs.filesystem.synopsis]"/></section>
<submitter>P.J. Plauger</submitter>
<date>30 Jan 2014</date>

<discussion>
<p>
<tt>directory_options::skip_permission_denied</tt> is not used.
</p>
  <note>2014-04-13 Beman: <tt>skip_permissions_denied</tt> not being used is a
  symptom of a more serious problem; two <tt>directory_itorator</tt> constructors
  are missing <tt>directory_options</tt> arguments and a description of how they
  are used. Proposed wording provided.</note>
</discussion>

<resolution>
  <p>
    <i>Change 13  [class.directory_iterator]:</i>
  </p>
  <blockquote>
    <pre>directory_iterator() noexcept;
explicit directory_iterator(const path&amp; p<ins>,</ins>
  <ins>directory_options options = directory_options::none</ins>);
directory_iterator(const path&amp; p,
  <ins>directory_options options,</ins> error_code&amp; ec) noexcept;
directory_iterator(const directory_iterator&amp;) = default;
directory_iterator(directory_iterator&amp;&amp;) = default;
~directory_iterator();</pre>
  </blockquote>
  <p>
    <i>Change 13.1 directory_iterator members [directory_iterator.members]:</i>
  </p>
  <blockquote>
    <pre>explicit directory_iterator(const path&amp; p<ins>,</ins>
  <ins>directory_options options = directory_options::none</ins>);
directory_iteratorconst path&amp; p,
  <ins>directory_options options,</ins> error_code&amp; ec) noexcept;</pre>
    <p>
      <i>Effects:</i> For the directory that <code>p</code> resolves to,
      constructs an iterator for the first element in a sequence of <code>
        directory_entry
      </code> elements representing the files in the directory, if
      any; otherwise the end iterator.
    </p>
    <p>
      <ins>
        However, if <code>options &amp; directory_options::skip_permissions_denied != 0</code>
        and construction encounters an error indicating that permission to access&nbsp;
        <code>p</code> is denied, construct the end iterator and do not report an
        error.
      </ins>
    </p>
  </blockquote>
  <p>
    <i>Change 14.1 recursive_directory_iterator members [rec.dir.itr.members]:</i>
  </p>
  <blockquote>
    <pre>explicit recursive_directory_iterator(const path&amp; p,
  directory_options options = directory_options::none);
recursive_directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec) noexcept;
  recursive_<code>directory_iterator(</code>const path&amp; p, error_code&amp; ec<code>) noexcept;</code></pre>
    <p>
      <i>Effects:</i>&nbsp; Constructs a iterator representing the first entry in the
      directory <code>p</code> resolves to, if any; otherwise, the end iterator.
    </p>
    <p>
      <ins>
        However, if <code>options &amp; directory_options::skip_permissions_denied != 0</code>
        and construction encounters an error indicating that permission to access&nbsp;
        <code>p</code> is denied, construct the end iterator and do not report an
        error.
      </ins>
    </p>
  </blockquote>
  <p>
    <i>Change 14.1 recursive_directory_iterator members [rec.dir.itr.members]:</i>
  </p>
  <blockquote>
    <pre>recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec);</pre>
    <p>
      <i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.
    </p>
    <p>
      <i>Effects:</i> As specified by C++11 § 24.1.1 Input iterators, except
      that:
    </p>
    <ul>
      <li>If there are no more entries at this depth, then if <code>depth()!= 0</code>
        iteration over the parent directory resumes; otherwise <code>
          *this =
          recursive_directory_iterator()</code>.</li>
      <li>Otherwise if <code>recursion_pending() &amp;&amp; is_directory(this-&gt;status())
          &amp;&amp; (!is_symlink(this-&gt;symlink_status()) || (options() &amp;
          directory_options::follow_directory_symlink) != 0)</code> then <ins>either</ins> directory
        <code>(*this)-&gt;path()</code> is recursively iterated into
        <ins>or, if <code>options() &amp; directory_options::skip_permissions_denied != 0</code>
          and an error indicating that permission to access directory
          <code>(*this)-&gt;path()</code> is denied, then directory <code>(*this)-&gt;path()</code> is
          treated as an empty directory and no error is reported</ins>.</li>
    </ul>
  </blockquote>
</resolution>

</issue>
