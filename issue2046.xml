<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="2046" status="New">
<title><tt>shared_future(future&lt;R&gt;&amp;&amp;)</tt> should be allowed to throw</title>
<section><sref ref="[futures.shared_future]"/></section>
<submitter>Peter Sommerlad</submitter>
<date>4 Apr 2011</date>

<discussion>

<p>
Requiring the constructor <tt>shared_future(future&lt;R&gt;&amp;&amp; rhs)</tt> not to throw 
is a pessimisation of the case where a future is returned from a call to 
<tt>async(function,launch::deferred)</tt> and possible other cases.
<p/>
Such a future not dealing with multiple threads only needs to keep (a copy of) the function 
to be called it later. However, creating a <tt>shared_future</tt> from that future will require more 
infrastructure, like space for the value of type <tt>R</tt>, an <tt>exception_ptr</tt>, and a synchronized 
reference counter for the <tt>shared_future</tt>'s instances.
<p/>
Enforcing the constructor <tt>shared_future(future&lt;R&gt;&amp;&amp; rhs)</tt> not to throw, 
implies that any implementation of <tt>future</tt> will need to pre-allocate space for <tt>shared_future</tt>'s 
infrastructure, that also requires an operating system resource for synchronization, regardless 
if is ever needed.
<p/>
All this came up when discussing D/N3267 and Concurrency Working Group decided that the constructor 
<tt>shared_future(future&lt;R&gt;&amp;&amp; rhs)</tt> should be allowed to throw. 
</p>
</discussion>

<resolution>

<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>In <sref ref="[futures.shared_future]"/> p. 3, change class template <tt>shared_future</tt> synopsis 
as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class R&gt;
  class shared_future {
  public:
    shared_future() noexcept;
    shared_future(const shared_future&amp; rhs);
    shared_future(future&lt;R&gt;&amp;&amp;) <del>noexcept</del>;
    shared_future(shared_future&amp;&amp; rhs) noexcept;
    ~shared_future();

    [&hellip;]

  };
}
</pre></blockquote>

</li>

<li><p>Edit <sref ref="[futures.shared_future]"/> before p. 9, and insert two new paragraphs as indicated:</p>

<blockquote><pre>
shared_future(future&lt;R&gt;&amp;&amp;) <del>noexcept</del>;
</pre><blockquote>
<p><ins>? - <i>Effects</i>:</ins></p>
<ul>
<li><ins>constructs a <tt>shared_future</tt> object that refers to the shared state that was originally 
referred to by <tt>rhs</tt> (if any).</ins></li>
<li><ins>If the constructor exits with an exception, <tt>rhs</tt> shall remain unchanged.</ins></li>
</ul>
<p>
<ins>? - <i>Postconditions</i>:</ins></p>
<ul>
<li><ins><tt>valid()</tt> returns the same value as <tt>rhs.valid()</tt> returned prior to the constructor invocation.</ins></li>
<li><ins><tt>rhs.valid() == false</tt>.</ins></li>
</ul>
</blockquote>
<pre>
shared_future(shared_future&amp;&amp; rhs) noexcept;
</pre><blockquote><p>
9 - <i>Effects</i>: move constructs a <tt>shared_future</tt> object that refers to the shared state that was originally
referred to by <tt>rhs</tt> (if any).
<p/>
10 - <i>Postconditions</i>:</p>
<ul>
<li><tt>valid()</tt> returns the same value as <tt>rhs.valid()</tt> returned prior to the constructor invocation.</li>
<li><tt>rhs.valid() == false</tt>.</li>
</ul>
</blockquote>
</blockquote>

</li>
</ol>

</resolution>

</issue>
