<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [
  <!ENTITY nbsp "&#160;">
] >

<issue num="1469" status="Open">
<title>FCD Ballot Comment GB-133</title>
<section><sref ref="[atomics.types.generic]"/></section>
<submitter>BSI</submitter>
<date>25 Aug 2010</date>

<discussion>
The free functions that operate on atomic_address can be
used to store a pointer to an unrelated type in an
atomic&lt;T*&gt; without a cast. e.g.
<PRE>
int i;
atomic&lt;int*&gt; ai(&amp;i);
string s;
atomic_store(&amp;ai,&amp;s);
</PRE>
</discussion>

<resolution>
Overload the atomic_store, atomic_exchange and
atomic_compare_exchange_[weak/strong]
operations for atomic&lt;T*&gt; to allow storing only
pointers to T:
<PRE>
template&lt;typename T&gt;
void atomic_store(atomic&lt;T*&gt;&amp;,T*);
template&lt;typename T&gt;
void atomic_store(atomic&lt;T*&gt;&amp;,void*) = delete;
template&lt;typename T&gt;
void
atomic_store_explicit(atomic&lt;T*&gt;&amp;,T*,memory_or
der);
template&lt;typename T&gt;
void
atomic_store_explicit(atomic&lt;T*&gt;&amp;,void*,memory
_order) = delete;
template&lt;typename T&gt;
T* atomic_exchange(atomic&lt;T*&gt;&amp;,T*);
template&lt;typename T&gt;
T* atomic_exchange(atomic&lt;T*&gt;&amp;,void*) = delete;
template&lt;typename T&gt;
T*
atomic_exchange_explicit(atomic&lt;T*&gt;&amp;,T*,memor
y_order);
template&lt;typename T&gt;
T*
atomic_exchange_explicit(atomic&lt;T*&gt;&amp;,void*,me
mory_order) = delete;
template&lt;typename T&gt;
T*
atomic_compare_exchange_weak(atomic&lt;T*&gt;&amp;,T
**,T*);
template&lt;typename T&gt;
T*
atomic_compare_exchange_weak(atomic&lt;T*&gt;&amp;,v
oid**,void*) = delete;
template&lt;typename T&gt;
T*
atomic_compare_exchange_weak_explicit(atomic
&lt;T*&gt;&amp;,T**,T*,memory_order);
template&lt;typename T&gt;
T*
atomic_compare_exchange_weak_explicit(atomic
&lt;T*&gt;&amp;,void**,void*,memory_order) = delete;
template&lt;typename T&gt;
T*
atomic_compare_exchange_strong(atomic&lt;T*&gt;&amp;,
T**,T*);
template&lt;typename T&gt;
T*
atomic_compare_exchange_strong(atomic&lt;T*&gt;&amp;,
void**,void*) = delete;
template&lt;typename T&gt;
T*
atomic_compare_exchange_strong_explicit(atomi
c&lt;T*&gt;&amp;,T**,T*,memory_order);
template&lt;typename T&gt;
T*
atomic_compare_exchange_strong_explicit(atomi
c&lt;T*&gt;&amp;,void**,void*,memory_order) = delete;
</PRE>
</resolution>

</issue>
