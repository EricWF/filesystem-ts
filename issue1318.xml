<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="1318" status="Open">
<title>N2982 removes previous allocator capabilities</title>
<section><sref ref="[allocator.traits.types]"/></section>
<submitter>Pete Becker</submitter>
<date>11 Feb 2010</date>

<discussion>
<p><b>Addresses US-87</b></p>
<p>
<a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>
says that containers should have a nested typedef that defines their
<tt>reference_type</tt> as <tt>value_type&amp;</tt>; the previous
standard deferred to the allocator to define its
<tt>reference_type</tt>, and containers simply passed the allocator's
typedef on. This change is a mistake. Allocators should define both a
<tt>pointer</tt> type and a <tt>reference</tt> type. That's essential
for their original purpose, which was to make different memory models
transparent. If an allocator defines a <tt>pointer</tt> type that isn't
compatible with a normal pointer it also has to define a corresponding
<tt>reference</tt> type. For example (and please forgive a Windows-ism),
if an allocator's pointer is <tt>T __far*</tt>, then it's
<tt>reference</tt> has to be <tt>T __far&amp;</tt>. Otherwise everything
crashes (under the hood, references are pointers and have to have the
same memory access mechanics). Extensions such as this for more general
memory models were explicitly encouraged by C++03, and the allocator's
<tt>pointer</tt> and <tt>reference</tt> typedefs were the hooks for such
extensions. Removing the allocator's <tt>reference</tt> and
<tt>const_reference</tt> typedefs makes those extensions unimplementable
and breaks existing implementations that rely on those hooks.
</p>

<note>
2010-02-25 Alisdair adds:
</note>

<blockquote>
<p>
<tt>vector&lt;bool&gt;::reference</tt> is a nested class, and not a typedef.  It
should be removed from the list of containers when this change is made.
</p>

<p>
In general, I am uncomfortable placing this reference requirement on each
container, as I would prefer to require:
</p>

<blockquote><pre>
is_same&lt;Container::reference, Container::iterator::reference&gt;
</pre></blockquote>

<p>
This distinction is important, if we intend to support proxy iterators.  The
iterator paper in the pre-Pittsburgh mailing
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3046.html">N3046</a>)
does <em>not</em> make this proposal, but organises clause 24 in such a way this
will be much easier to specify.
</p>

<p>
The changes to clause 20 remain important for all the reasons Pete highlights.
</p>
</blockquote>

<note>
2010 Batavia
</note>

<p>
Removed <tt>vector</tt> from list of templates that should be adjusted as of meeting outcome.
</p>

<note>
2010 post-Batavia
</note>

<p>
Replaced <tt>vector&lt;bool&gt;</tt> reference by <tt>vector</tt> reference because of misinterpreting meeting typo.
Additional corrected numbering in P/R to N3225 wording.
</p>

<note>
2010-12-06 Daniel reopens
</note>

<p>
Unfortunately, the current P/R is defective for several reasons:
</p>
<ol>
<li> Table 43 &mdash; Descriptive variable definitions still contains three
references to <tt>T&amp;</tt>, namely in:
<blockquote>
<table border="1">
<tr>
<td>
<tt>t</tt>
</td>
<td>a value of type <tt>const T&amp;</tt></td>
</tr>
<tr>
<td>
<tt>r</tt>
</td>
<td>a value of type <tt>T&amp;</tt> obtained by the expression <tt>*p</tt></td>
</tr>
<tr>
<td>
<tt>s</tt>
</td>
<td>a value of type <tt>const T&amp;</tt> obtained by the expression <tt>*q</tt>
or by conversion from a value <tt>r</tt></td>
</tr>
</table>
</blockquote>
Especially the second and third items are misses in the 1318 P/R,
e.g. in N2723 or in C++03 these were referring
to <tt>X::reference</tt> and <tt>X::const_reference</tt>, resp.
None of them is referenced anywhere in the allocator requirements
table: <tt>r</tt> and <tt>s</tt> where historically needed to
define the expressions <tt>a.address(r)</tt> and <tt>a.address(s)</tt> which are gone now,
and <tt>t</tt> was needed to define the expression <tt>a.construct(p, t)</tt> which has been
replaced by <tt>a.construct(p,args)</tt>.
<p/>
The easiest fix seems to be to remove all three rows from Table 43.
</li>
<li>
Further-on, the current P/R suggests to replace the the current
definitions of the adaptor classes
<blockquote><pre>
stack
priority_queue
queue
</pre></blockquote>
similar to the other container types, i.e. to define <tt>reference</tt> and
<tt>const_reference</tt> now as
<blockquote><pre>
typedef typename allocator_traits&lt;Allocator&gt;::reference reference;
typedef typename allocator_traits&lt;Allocator&gt;::const_reference const_reference;
</pre></blockquote>
This would not only be an ill-formed definition (because there is no name
<tt>Allocator</tt> in scope), but it would also introduce a breakage compared to C++03,
where these definitions where already referring to the definition of the wrapped 
containers. So, the adaptor class templates should be removed from the current list.
</li>
<li>
Then the current P/R wording leads to one further unexpected and unwanted change due to 
the general formular used: <tt>match_result::reference</tt> is currently defined as
<blockquote><pre>
typedef const_reference reference;
</pre></blockquote>
because it is an <em>immutable</em> container (And we had this definition
already in N2723). The application of the rule would change this silently.
</li>
<li>
Finally the suggested wording for the <tt>unordered_</tt> containers is incomplete.
The reason is a current inconsistency between these containers and the rest: While
normally the definition of the pointer types is
<blockquote><pre>
typedef typename allocator_traits&lt;Allocator&gt;::pointer pointer;
typedef typename allocator_traits&lt;Allocator&gt;::const_pointer const_pointer;
</pre></blockquote>
for the unordered containers they are
<blockquote><pre>
typedef typename allocator_type::pointer pointer;
typedef typename allocator_type::const_pointer const_pointer;
</pre></blockquote>
These definitions are <em>not</em> equivalent, because allocators are no longer
required to define typedefs <tt>pointer</tt> and <tt>const_pointer</tt>, the
<tt>allocator_traits</tt> were invented as a further indirection to cope
with that. I.e. for the unordered containers we need to bring both the definition
of references <em>and</em> pointers in sync.
</li>
</ol>

<note>
2011-02-23 Daniel updates the proposed wording with support from Pablo
</note>

<p>The update attempts to fix the backward-compatibility problem that we have
introduced by ignoring the C++03 member function overloads <tt>address</tt>
of allocator types in C++0x completely. The resolution attempts to fix that
by adding these functions as optional members of allocators that are considered
first before falling back to <tt>pointer_traits::pointer_to</tt>. This still
allows us to remove the unused symbol <tt>t</tt> from the table, but we adapt
the symbols <tt>r</tt> and <tt>s</tt> to purely refer to the typenames
<tt>reference</tt> and <tt>const_reference</tt>.</p>

<note>2011-03-06 Daniel adapts numbering to N3242</note>

<note>2011-03-11 Daniel removes <tt>noexcept</tt> specifiers from <tt>address</tt> functions</note>

<note>2011-03-12 Further wording improvements by Daniel and Pablo</note>

</discussion>

<resolution>
<ol>
<li>
<p>
Edit the following rows from <sref ref="[allocator.requirements]"/>, Table 27 &quot;Descriptive variable definitions&quot;:
</p>

<blockquote>
<table border="1">
<caption>Table 27 &mdash; Descriptive variable definitions</caption>
<tr>
<th>
Variable
</th>

<th>
Definition
</th>
</tr>

<tr>
<td><del><tt>t</tt></del></td>

<td><del>a value of type <tt>const T&amp;</tt></del></td>

</tr>

<tr>
<td colspan="2" style="text-align:center;">[&hellip;]</td>
</tr>

<tr>
<td><tt>r</tt></td>

<td>a value of type <tt><del>T&amp;</del><ins>XX::reference</ins></tt> obtained by the expression <tt>*p</tt>.</td>

</tr>

<tr>
<td><tt>s</tt></td>

<td>a value of type <tt><del>const T&amp;</del><ins>XX::const_reference</ins></tt> obtained by the expression <tt>*q</tt> or
by conversion from a value <tt>r</tt>.</td>

</tr>

</table>
</blockquote>

</li>
<li>
<p>
Edit the contents from <sref ref="[allocator.requirements]"/>, Table 28, &quot;Allocator requirements&quot; as indicated:
</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>
Expression
</th>

<th>
Return type
</th>

<th>
Assertion/note<br/>pre-/post-condition
</th>

<th>
Default
</th>

</tr>

<tr>
<td colspan="4" style="text-align:center;">[&hellip;]</td>
</tr>

<tr>
<td><ins><tt>X::reference</tt></ins></td>

<td><tt></tt></td>

<td><tt></tt></td>

<td><ins><tt>T&amp;</tt></ins></td>
</tr>

<tr>
<td><ins><tt>X::const_reference</tt></ins></td>

<td><tt></tt></td>

<td><ins><tt>X::reference</tt> is convertible to<br/>
<tt>X::const_reference</tt></ins></td>

<td><ins><tt>const T&amp;</tt></ins></td>
</tr>

<tr>
<td><tt>X::value_type</tt></td>

<td>Identical to <tt>T</tt></td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">[&hellip;]</td>
</tr>

<tr>
<td><tt>*p</tt></td>

<td><tt><del>T&amp;</del><ins>X::reference</ins></tt></td>

<td><tt></tt></td>

<td></td>
</tr>

<tr>
<td><tt>*q</tt></td>

<td><tt><del>const T&amp;</del><ins>X::const_reference</ins></tt></td>

<td><tt>*q</tt> refers to the same object as <tt>*p</tt></td>

<td></td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">[&hellip;]</td>
</tr>

<tr>
<td><tt>static_cast&lt;X::pointer&gt;(w)</tt></td>

<td><tt>X::pointer</tt></td>

<td><tt>static_cast&lt;X::pointer&gt;(w)<br/>== p</tt></td>

<td>&nbsp;</td>
</tr>

<tr>
<td><tt>static_cast&lt;X::const_pointer&gt;(z)</tt></td>

<td><tt>X::const_pointer</tt></td>

<td><tt>static_cast&lt;X::const_pointer&gt;(z)<br/>== q</tt></td>

<td>&nbsp;</td>
</tr>

<tr>
<td><ins><tt>a.address(r)</tt></ins></td>

<td><ins><tt>X::pointer</tt></ins></td>

<td><ins><tt>a.address(r) == p</tt></ins></td>

<td><ins><tt>pointer_traits&lt;X::pointer&gt;::pointer_to(r)</tt></ins></td>
</tr>

<tr>
<td><ins><tt>a.address(s)</tt></ins></td>

<td><ins><tt>X::const_pointer</tt></ins></td>

<td><ins><tt>a.address(s) == q</tt></ins></td>

<td><ins><tt>pointer_traits&lt;X::const_pointer&gt;::pointer_to(s)</tt></ins></td>
</tr>

</table>
</blockquote>

</li>

<li><p>Add the following sentence at the end of <sref ref="[allocator.requirements]"/> p. 3 (The intent is
to ensure that any allocator rebind satisfies the allocator requirements as well)</p>

<blockquote><p>
-3- Note A: The member class template <tt>rebind</tt> in the table above is effectively a typedef template. 
[ <i>Note</i>: In general, if the name <tt>Allocator</tt> is bound to <tt>SomeAllocator&lt;T&gt;</tt>, then 
<tt>Allocator::rebind&lt;U&gt;::other</tt> is the same type as <tt>SomeAllocator&lt;U&gt;</tt>, 
where <tt>SomeAllocator&lt;T&gt;::value_type</tt> is <tt>T</tt> and <tt>SomeAllocator&lt;U&gt;::value_type</tt> 
is U. &mdash; <i>end note</i> ] If <tt>Allocator</tt> is a class template instantiation of the 
form <tt>SomeAllocator&lt;T, Args&gt;</tt>, where <tt>Args</tt> is zero or more type arguments, 
and <tt>Allocator</tt> does not supply a <tt>rebind</tt> member template, the standard 
<tt>allocator_traits</tt> template uses <tt>SomeAllocator&lt;U, Args&gt;</tt> in place of 
<tt>Allocator::rebind&lt;U&gt;::other</tt> by default. For allocator types that are not template 
instantiations of the above form, no default is provided. <ins>The types referred to by <tt>X::rebind&lt;U&gt;::other</tt> 
(if <tt>X::rebind</tt> is supplied) and by <tt>allocator_traits&lt;X&gt;::rebind_alloc&lt;U&gt;</tt> 
shall satisfy the Allocator requirements for every type <tt>U</tt> used to instantiate them.</ins>
</p></blockquote>

</li>

<li><p>Add the following new paragraph after <sref ref="[allocator.requirements]"/> paragraph 4 (The 
intent is to make implementors conforming that only support built-in reference types, but to allow
them to support extended reference types as well), additionally paragraph 4 i reworded to be more
specific about the requirements on the different pointer typedefs:</p> 

<blockquote>
<p>
-4- <del>The <tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and 
<tt>X::const_void_pointer</tt> types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). 
No constructor, comparison operator, copy operation, move operation, or swap operation on these 
types shall exit via an exception. <tt>X::pointer</tt> and <tt>X::const_pointer</tt> shall also 
satisfy the requirements for a random access iterator (24.2).</del><ins>For every type <tt>X</tt>
that meets the Allocator requirements, the types referred to by <tt>X::pointer</tt>, 
<tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt>
and the types referred to by <tt>allocator_traits&lt;X&gt;::pointer</tt>,
<tt>allocator_traits&lt;X&gt;::const_pointer</tt>, <tt>allocator_traits&lt;X&gt;::void_pointer</tt>,
and <tt>allocator_traits&lt;X&gt;::const_void_pointer</tt> shall satisfy the <tt>NullablePointer</tt> 
requirements (<sref ref="[nullablepointer.requirements]"/>). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these types shall exit via an exception.
Additionally, the types referred to by <tt>X::pointer</tt>, <tt>X::const_pointer</tt>, 
<tt>allocator_traits&lt;X&gt;::pointer</tt>, and <tt>allocator_traits&lt;X&gt;::const_pointer</tt> 
shall also satisfy the requirements for a random access iterator (<sref ref="[random.access.iterators]"/>).</ins>
<p/>
<ins>-?- For every component described in this International Standard that is parameterized in 
terms of a type, denoted here as <tt><i>A</i></tt>, that is required to satisfy the 
Allocator requirements, the type referred to by <tt><i>A</i>::value_type&amp;</tt> shall be a valid 
definition for <tt><i>A</i>::reference</tt> or for <tt>allocator_traits&lt;<i>A</i>&gt;::reference</tt> 
and the type referred to by <tt>const <i>A</i>::value_type&amp;</tt> shall be a valid definition for 
<tt><i>A</i>::const_reference</tt> or for <tt>allocator_traits&lt;<i>A</i>&gt;::const_reference</tt>. 
An implementation may define other valid definitions for these member types. [<i>Note</i>: For example, an 
implementation that supports <tt>_ _ far</tt> references might support 
<tt><i>A</i>::value_type _ _ far&amp;</tt> as a valid definition for <tt><i>A</i>::reference</tt>. 
&mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

<li><p>Add the following paragraph after <sref ref="[pointer.traits]"/> p. 1 (The intent is to
encourage non-normatively implementations to provide specializations for <tt>pointer_traits</tt>
for non-standard pointer types and reference types which are native for the supported
platform):</p>

<blockquote><p>
-1- The class template <tt>pointer_traits</tt> supplies a uniform interface to certain attributes 
of pointer-like types.
</p><blockquote><pre>
namespace std {
  template &lt;class Ptr&gt; struct pointer_traits {
    typedef Ptr pointer;
    typedef <em>see below</em> element_type;
    typedef <em>see below</em> difference_type;
    template &lt;class U&gt; using rebind = <em>see below</em>;
    static pointer pointer_to(<em>see below</em> r);
  };

  template &lt;class T&gt; struct pointer_traits&lt;T*&gt; {
    typedef T* pointer;
    typedef T element_type;
    typedef ptrdiff_t difference_type;
    template &lt;class U&gt; using rebind = U*;
    static pointer pointer_to(<em>see below</em> r);
  };
}
</pre></blockquote>
<p>
<ins>-?- An implementation is permitted to define additional specializations for <tt>pointer_traits</tt> 
corresponding to implementation-defined pointer types. [ <i>Note</i>: If there is an additional pointer type 
<tt>_ _ far*</tt> such that the difference of two <tt>_ _ far*</tt> is of type <tt>long</tt>, an 
implementation may define</ins></p>
<blockquote><pre>
<ins>namespace std {
  template &lt;class T&gt; struct pointer_traits&lt;T _ _ far*&gt; {
    typedef T _ _ far* pointer;
    typedef T element_type;
    typedef long difference_type;
    template &lt;class U&gt; using rebind = U _ _ far*;
    static pointer pointer_to(T _ _ far&amp; r); <i>// For non-</i>void T
  };
}</ins>
</pre></blockquote>
<p><ins>&mdash; <i>end note</i> ]</ins></p>
</blockquote>
</li>

<li>
<p>
Add the following typedef and function declarations to class template <tt>allocator_traits</tt> 
<sref ref="[allocator.traits]"/>. Please note here, that the declarations with <tt>noexcept</tt> specifier
of the <tt>address</tt> functions of allocators of an earlier proposed resolution has been removed. The C++03 
standard seems not to impose this requirement and the equivalent function <tt>pointer_traits&lt;&gt;::pointer_to()</tt>
does also not have such a specifier. It seems perfectly possibly that throwing <tt>address</tt> functions 
should be supported, but it should now to be decided, whether a conditional <tt>noexcept</tt> specification 
should be added here and in <tt>scoped_allocator_adaptor</tt> as well:
</p>

<blockquote><pre>
template &lt;class Alloc&gt; struct allocator_traits {
  ...
  typedef <i>see below</i> void_pointer;
  typedef <i>see below</i> const_void_pointer;

  <ins>typedef <i>see below</i> reference;</ins>
  <ins>typedef <i>see below</i> const_reference;</ins>
  ...
  <ins>static pointer address(Alloc&amp; a, reference r);</ins>
  <ins>static const_pointer address(Alloc&amp; a, const_reference r);</ins>

  static pointer allocate(Alloc&amp; a, size_type n);
  static pointer allocate(Alloc&amp; a, size_type n, const_void_pointer hint);
  ...
</pre></blockquote>
</li>

<li>
<p>
Add the following descriptions to <sref ref="[allocator.traits.types]"/> after p. 4:
</p>

<blockquote>
<pre>typedef <i>see below</i> const_void_pointer;</pre>
<blockquote><p>
4 <i>Type:</i> <tt>Alloc::const_void_pointer</tt> if such a type exists; otherwise,
<tt>pointer_traits&lt;pointer&gt;::rebind&lt;const void&gt;</tt>.
</p></blockquote>

<pre><ins>typedef <i>see below</i> reference;</ins></pre>
<blockquote><p>
<ins>? <i>Type:</i> <tt>Alloc::reference</tt> if such a type exists; otherwise,
<tt>value_type&amp;</tt>.</ins>
</p></blockquote>

<pre><ins>typedef <i>see below</i> const reference;</ins></pre>
<blockquote><p>
<ins>? <i>Type:</i> <tt>Alloc::const_reference</tt> if such a type exists; otherwise,
<tt>const value_type&amp;</tt>.</ins>
</p></blockquote>
</blockquote>
</li>

<li>
<p>
Add the following descriptions at the beginning of <sref ref="[allocator.traits.members]"/>:
</p>

<blockquote>
<pre><ins>static pointer address(Alloc&amp; a, reference r);</ins></pre>
<blockquote><p>
<ins>? <i>Returns:</i> <tt>a.address(r)</tt> if that expression is well-formed; otherwise,
<tt>pointer_traits&lt;pointer&gt;::pointer_to(r)</tt>.</ins>
</p></blockquote>

<pre><ins>static const_pointer address(Alloc&amp; a, const_reference r);</ins></pre>
<blockquote><p>
<ins>? <i>Returns:</i> <tt>a.address(r)</tt> if that expression is well-formed; otherwise,
<tt>pointer_traits&lt;const_pointer&gt;::pointer_to(r)</tt>.</ins>
</p></blockquote>

<pre>static pointer allocate(Alloc&amp; a, size_type n);</pre>
<blockquote><p>
1 <i>Returns:</i> <tt>a.allocate(n)</tt>.
</p></blockquote>
</blockquote>
</li>

<li>
<p>
Add the following typedef and member function declarations to the
<tt>scoped_allocator_adaptor</tt> synopsis in <sref ref="[allocator.adaptor.syn]"/>:
</p>

<blockquote><pre>
template &lt;class OuterAlloc, class... InnerAllocs&gt;
class scoped_allocator_adaptor : public OuterAlloc {
  ...
  <ins>typedef typename OuterTraits::reference reference;</ins>
  <ins>typedef typename OuterTraits::const_reference const_reference;</ins>
  ...
  <ins>pointer address(reference r);</ins>
  <ins>const_pointer address(const_reference r);</ins>

  pointer allocate(size_type n);
  ...
</pre></blockquote>
</li>

<li><p>Add the following prototype descriptions to <sref ref="[allocator.adaptor.members]"/>:</p>

<blockquote>
<pre>const outer_allocator_type&amp; outer_allocator() const noexcept;</pre>
<blockquote><p>
4 <i>Returns:</i> <tt>static_cast&lt;const Outer&amp;&gt;(*this)</tt>.
</p></blockquote>

<pre><ins>pointer address(reference r);</ins></pre>
<blockquote><p>
<ins>? <i>Returns:</i> <tt>allocator_traits&lt;OuterAlloc&gt;::address(outer_allocator(), r)</tt>.</ins>
</p></blockquote>

<pre><ins>const_pointer address(const_reference r);</ins></pre>
<blockquote><p>
<ins>? <i>Returns:</i> <tt>allocator_traits&lt;OuterAlloc&gt;::address(outer_allocator(), r)</tt>.</ins>
</p></blockquote>

<pre>pointer allocate(size_type n);</pre>
<blockquote><p>
5 <i>Returns:</i> <tt>allocator_traits&lt;OuterAlloc&gt;::allocate(outer_allocator(), n)</tt>.
</p></blockquote>
</blockquote>
</li>

<li>
<p>
Change the nested typedefs <tt>reference</tt> and <tt>const_reference</tt> to:
</p>

<blockquote><pre>
typedef typename allocator_traits&lt;Allocator&gt;::reference reference;
typedef typename allocator_traits&lt;Allocator&gt;::const_reference const_reference;
</pre></blockquote>

<p>
for each of the following class templates:
</p>

<blockquote><p>
<tt>basic_string</tt> <sref ref="[basic.string]"/><br/>
<tt>deque</tt> <sref ref="[deque]"/><br/>
<tt>forward_list</tt> <sref ref="[forwardlist]"/><br/>
<tt>list</tt> <sref ref="[list]"/><br/>
<tt>vector</tt> <sref ref="[vector]"/><br/>
<tt>map</tt> <sref ref="[map]"/><br/>
<tt>multimap</tt> <sref ref="[multimap]"/><br/>
<tt>set</tt> <sref ref="[set]"/><br/>
<tt>multiset</tt> <sref ref="[multiset]"/><br/>
</p></blockquote>
</li>

<li>
<p>
Change the nested typedefs <tt>reference</tt> and <tt>const_reference</tt> to:
</p>

<blockquote><pre>
typedef typename allocator_traits&lt;Allocator&gt;::reference reference;
typedef typename allocator_traits&lt;Allocator&gt;::const_reference const_reference;
</pre></blockquote>

<p>
and change the nested typedefs <tt>pointer</tt> and <tt>const_pointer</tt> to:
</p>

<blockquote><pre>
typedef typename allocator_traits&lt;Allocator&gt;::pointer pointer;
typedef typename allocator_traits&lt;Allocator&gt;::const_pointer const_pointer;
</pre></blockquote>

<p>
for each of the following class templates:
</p>

<blockquote><p>
<tt>unordered_map</tt> <sref ref="[unord.map]"/><br/>
<tt>unordered_multimap</tt> <sref ref="[unord.multimap]"/><br/>
<tt>unordered_set</tt> <sref ref="[unord.set]"/><br/>
<tt>unordered_multiset</tt> <sref ref="[unord.multiset]"/><br/>
</p></blockquote>
</li>

<li>
<p>
Edit the class template synopsis of <tt>match_results</tt> in <sref ref="[re.results]"/>
as indicated:
</p>

<blockquote><pre>
template &lt;class BidirectionalIterator,
class Allocator = allocator&lt;sub_match&lt;BidirectionalIterator&gt; &gt;
class match_results {
public:
  typedef sub_match&lt;BidirectionalIterator&gt; value_type;
  typedef <del>const value_type&amp;</del><ins>typename allocator_traits&lt;Allocator&gt;::const_reference</ins> const_reference;
  typedef const_reference reference;
  ...
};
</pre></blockquote>
</li>
</ol>
</resolution>

</issue>
