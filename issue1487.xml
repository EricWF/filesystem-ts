<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [
  <!ENTITY nbsp "&#160;">
] >

<issue num="1487" status="Open">
<title>[FCD] Clock related operations exception specifications conflict</title>
<section><sref ref="[thread.thread.this]"/></section>
<submitter>Switzerland</submitter>
<date>25 Aug 2010</date>

<discussion>
<p><b>Addresses CH-25</b></p>
<p>
Clock related operations are currently not required not to
throw. So "Throws: Nothing." is not always true.
</p>
<note>
Resolution proposed by ballot comment:
</note>
<blockquote><p>
Either require clock related operations not to throw
(in 20.10) or change the Throws clauses in 30.3.2.
Also possibly add a note that <tt>abs_time</tt> in the past
or negative <tt>rel_time</tt> is allowed.
</p></blockquote>

<note>2011-02-10: Howard Hinnant provides a resolution proposal</note>

<note>Previous proposed resolution:</note>
<ol>
<li>
<p>Change the Operational semantics of <tt>C1::now()</tt> in <sref ref="[time.clock.req]"/>, 
Table 59 &mdash; <tt>Clock</tt> requirements as follows:
</p>

<blockquote>
<table border="1">
<caption>Table 59 &mdash; <tt>Clock</tt> requirements</caption>
<tr>
<th>
Expression
</th>

<th>
Return type
</th>

<th>
Operational semantics
</th>

</tr>

<tr>
<td><tt>C1::now()</tt></td>

<td><tt>C1::time_point</tt></td>

<td>Returns a <tt>time_point</tt> object<br/>
representing the current point in time.<br/>
<ins>Shall not throw an exception.</ins></td>
</tr>

</table>
</blockquote>


</li>
</ol>

<note>2011-02-19: Daniel comments and suggests an alternative wording</note>

<p>Imposing the no-throw requirement on <tt>C1::now()</tt> of any clock time
is an overly radical step: It has the indirect consequences that representation
types for <tt>C1::rep</tt> can never by types with dynamic memory managment,
e.g. my <tt>big_int</tt>, which are currently fully supported by the time
utilities. Further-on this strong constraint does not even solve the problem
described in the issue, because we are still left with the fact that any
of the arithmetic operations of <tt>C1::rep</tt>, <tt>C1::duration</tt>,
and <tt>C1::time_point</tt> may throw exceptions.
</p>
<p>The alternative proposal uses the following strategy: The general <tt>Clock</tt>
requirements remain untouched, but we require that any functions of the library-provided
clocks from sub-clause <sref ref="[time.clock]"/> and their associated types shall not
throw exceptions. Second, we replace existing <tt>noexcept</tt> specifications of
functions from Clause 30 that depend on durations, clocks, or time points by wording that
clarifies that these functions can only throw, if the operations of user-provided durations,
clocks, or time points used as arguments to these functions throw exceptions.
</p>
</discussion>

<resolution>

<ol>
<li><p>Add the following new requirement set at the end of sub-clause <sref ref="[time.clock.req]"/>: [<i>Comment</i>:
This requirement set is <strong>intentionally</strong> incomplete. The reason for
this incompleteness is the based on the fact, that if we would make it right for C++0x, we would end up defining
something like a complete <tt>ArithmeticLike</tt> concept for <tt>TC::rep</tt>, <tt>TC::duration</tt>, and <tt>TC::time_point</tt>. 
But this looks out-of scope for C++0x to me. The effect is that we essentially do not exactly say, which arithmetic 
or comparison operations can be used in the time-dependent functions from Clause 30, even though I expect that
all declared functions of <tt>duration</tt> and <tt>time_point</tt> are well-formed and well-defined. &mdash; <i>end comment</i>]</p>
<blockquote><p>
3 [ <i>Note</i>: the relative difference in durations between those reported by a given clock and the SI definition is
a measure of the quality of implementation. &mdash; <i>end note</i> ]
</p></blockquote>

<blockquote><p>
<ins>? A type <tt>TC</tt> meets the <tt><i>TrivialClock</i></tt> requirements if:</ins>
</p>
<ul>
<li><p>
<ins><tt>TC</tt> satisfies the <tt>Clock</tt> requirements (<sref ref="[time.clock.req]"/>),</ins>
</p></li>
<li><p>
<ins>the types <tt>TC::rep</tt>, <tt>TC::duration</tt>, and <tt>TC::time_point</tt> satisfy 
the requirements of <tt>EqualityComparable</tt> (<sref ref="[equalitycomparable]"/>), <tt>LessThanComparable</tt> 
(<sref ref="[lessthancomparable]"/>), <tt>DefaultConstructible</tt> (<sref ref="[defaultconstructible]"/>), 
<tt>CopyConstructible</tt> (<sref ref="[copyconstructible]"/>), <tt>CopyAssignable</tt> (<sref ref="[copyassignable]"/>), 
<tt>Destructible</tt> (<sref ref="[destructible]"/>), and of numeric types ([numeric.requirements]) [<i>Note</i>: This means in 
particular, that operations of these types will not throw exceptions &mdash; <i>end note</i> ],</ins>
</p></li>
<li><p>
<ins>lvalues of the types <tt>TC::rep</tt>, <tt>TC::duration</tt>, and <tt>TC::time_point</tt> are swappable 
(<sref ref="[swappable.requirements]"/>),</ins>
</p></li>
<li><p>
<ins>the function <tt>TC::now()</tt> does not throw exceptions, and</ins>
</p></li>
<li><p>
<ins>the type <tt>TC::time_point::clock</tt> does meet the <tt>TrivialClock</tt> requirements, recursively.</ins>
</p></li>
</ul>
</blockquote>
</li>

<li>
<p>Modify <sref ref="[time.clock]"/> p. 1 as follows:</p>

<blockquote><p>
1 - The types defined in this subclause shall satisfy the <tt><ins>Trivial</ins>Clock</tt> requirements (20.11.1). 
</p></blockquote>
</li>

<li>
<p>Modify <sref ref="[time.clock.system]"/> p. 1, class <tt>system_clock</tt> synopsis, as follows:</p>

<blockquote><pre>
class system_clock {
public:
  typedef <i>see below</i> rep;
  typedef ratio&lt;<i>unspecified</i> , <i>unspecified</i> &gt; period;
  typedef chrono::duration&lt;rep, period&gt; duration;
  typedef chrono::time_point&lt;system_clock&gt; time_point;
  static const bool is_monotonic is_steady = <i>unspecified</i>;
  static time_point now() <ins>noexcept</ins>;
  // Map to C API
  static time_t to_time_t (const time_point&amp; t) <ins>noexcept</ins>;
  static time_point from_time_t(time_t t) <ins>noexcept</ins>;
};
</pre></blockquote>

</li>

<li>
<p>Modify the prototype declarations in <sref ref="[time.clock.system]"/> p. 3 + p. 4 as indicated (This 
edit also fixes the miss of the <tt>static</tt> specifier in these prototype declarations):</p>

<blockquote><pre>
<ins>static</ins> time_t to_time_t(const time_point&amp; t) <ins>noexcept</ins>;
</pre><blockquote><p>
3 - [...]
</p></blockquote>

<pre>
<ins>static</ins> time_point from_time_t(time_t t) <ins>noexcept</ins>;
</pre><blockquote><p>
4 - [...]
</p></blockquote>
</blockquote>

</li>

<li>
<p>Modify <sref ref="[time.clock.steady]"/> p. 1, class <tt>steady_clock</tt> synopsis, as follows:</p>

<blockquote><pre>
class steady_clock {
public:
  typedef <i>unspecified</i> rep;
  typedef ratio&lt;<i>unspecified</i> , <i>unspecified</i> &gt; period;
  typedef chrono::duration&lt;rep, period&gt; duration;
  typedef chrono::time_point&lt;<i>unspecified</i>, duration&gt; time_point;
  static const bool is_monotonic is_steady = true;

  static time_point now() <ins>noexcept</ins>;
};
</pre></blockquote>

</li>

<li>
<p> Modify <sref ref="[time.clock.hires]"/> p. 1, class <tt>high_resolution_clock</tt> synopsis, as follows:</p>

<blockquote><pre>
class high_resolution_clock {
public:
  typedef <i>unspecified</i> rep;
  typedef ratio&lt;<i>unspecified</i> , <i>unspecified</i> &gt; period;
  typedef chrono::duration&lt;rep, period&gt; duration;
  typedef chrono::time_point&lt;<i>unspecified</i>, duration&gt; time_point;
  static const bool is_monotonic is_steady = <i>unspecified</i>;

  static time_point now() <ins>noexcept</ins>;
};
</pre></blockquote>

</li>

<li><p>Add a new paragraph at the end of <sref ref="[thread.req.timing]"/>:</p>

<blockquote><p>
6 The resolution of timing provided by an implementation depends on both operating system and hardware.
The finest resolution provided by an implementation is called the <i>native resolution</i>.
</p></blockquote>

<blockquote><p>
<ins>? Implementation-provided clocks that are used for these functions shall meet the <tt>TrivialClock</tt>
requirements (<sref ref="[time.clock.req]"/>).</ins>
</p></blockquote>
</li>

<li>
<p>Edit the synopsis of <sref ref="[thread.thread.this]"/> before p. 1:</p>

<blockquote><pre>
template &lt;class Clock, class Duration&gt;
void sleep_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) <del>noexcept</del>;
template &lt;class Rep, class Period&gt;
void sleep_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) <del>noexcept</del>;
</pre></blockquote>
</li>

<li>
<p>Modify the prototype specifications in <sref ref="[thread.thread.this]"/> before p. 4 and p. 6 and
re-add a <i>Throws</i> element following the <i>Synchronization</i> elements at p. 5 and p. 7:</p>

<blockquote><pre>
template &lt;class Clock, class Duration&gt;
void sleep_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) <del>noexcept</del>;
</pre><blockquote><p>
4 - [...]
<p/>
5 - <i>Synchronization</i>: None.
<p/>
<ins>? - <i>Throws</i>: Nothing unless an exception is thrown by <tt>Clock::now()</tt> or by an operation of <tt>abs_time</tt>.
[<i>Note</i>: Instantiations of time point types and clocks supplied by the implementation as specified in <sref ref="[time.clock]"/> 
do not throw exceptions. &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class Rep, class Period&gt;
void sleep_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) <del>noexcept</del>;
</pre><blockquote><p>
6 [...]
<p/>
7 <i>Synchronization</i>: None.
<p/>
<ins>? <i>Throws</i>: Nothing unless an exception is thrown by an operation of <tt>rel_time</tt>.
[<i>Note</i>: Instantiations of duration types supplied by the implementation as specified in <sref ref="[time.clock]"/> 
do not throw exceptions. &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>
</li>

<li><p>Modify the <i>Throws</i> elements of <sref ref="[thread.timedmutex.requirements]"/> p. 9 and p. 16 as indicated and
modify the <i>Effects</i> elements p. 5 and p. 12 to clarify the lock state in the presence of exceptions. Note that
the edit also fixes a minor incorrectness in p. 5: Duration types need to compare against <tt>duration&lt;&gt;::zero()</tt>,
not <tt>0</tt>:</p>

<blockquote><p>
3 The expression <tt>m.try_lock_for(rel_time)</tt> shall be well-formed and have the following semantics:
<p/>
[...]
<p/>
5 <i>Effects</i>: The function attempts to obtain ownership of the mutex within the relative timeout (30.2.4)
specified by <tt>rel_time</tt>. If the time specified by <tt>rel_time</tt> is less than or equal to <del><tt>0</tt></del><ins><tt>rel_time.zero()</tt></ins>, 
the function attempts to obtain ownership without blocking (as if by calling <tt>try_lock()</tt>). The function shall return
within the timeout specified by <tt>rel_time</tt> only if it has obtained ownership of the mutex object <ins>or an exception is thrown</ins>.
<ins>If an exception is thrown then a lock shall not have been acquired for the current execution agent.</ins>
[ <i>Note</i>: As with <tt>try_lock()</tt>, there is no guarantee that ownership will be obtained if the lock is
available, but implementations are expected to make a strong effort to do so. &mdash; <i>end note</i> ]
<p/>
[...]
<p/>
9 <i>Throws</i>: Nothing <ins>unless an exception is thrown by an operation of <tt>rel_time</tt>.
[<i>Note</i>: Instantiations of duration types supplied by the implementation as specified in <sref ref="[time.clock]"/> 
do not throw exceptions. &mdash; <i>end note</i>]</ins>.
<p/>
10 The expression <tt>m.try_lock_until(abs_time)</tt> shall be well-formed and have the following semantics:
<p/>
[...]
<p/>
12 <i>Effects</i>: The function attempts to obtain ownership of the mutex. If <tt>abs_time</tt> has already passed, the function 
attempts to obtain ownership without blocking (as if by calling <tt>try_lock()</tt>). The function shall return before the
absolute timeout (30.2.4) specified by <tt>abs_time</tt> only if it has obtained ownership of the mutex object <ins>or an 
exception is thrown</ins>. <ins>If an exception is thrown then a lock shall not have been acquired for the current execution 
agent.</ins> [ <i>Note</i>: As with <tt>try_lock()</tt>, there is no guarantee that ownership will be obtained 
if the lock is available, but implementations are expected to make a strong effort to do so. &mdash; <i>end note</i> ]
<p/>
[...]
<p/>
16 <i>Throws</i>: Nothing <ins>unless an exception is thrown by the <tt>now()</tt> function of the
used clock or by an operation of <tt>abs_time</tt>.
[<i>Note</i>: Instantiations of time point types and clocks supplied by the implementation as specified in <sref ref="[time.clock]"/> 
do not throw exceptions. &mdash; <i>end note</i>]</ins>.
</p>
</blockquote>
</li>

<li><p>Modify the class <tt>timed_mutex</tt> synopsis in <sref ref="[thread.timedmutex.class]"/> as indicated:</p>

<blockquote><pre>
class timed_mutex {
public:
  [...]
  template &lt;class Rep, class Period&gt;
    bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) <del>noexcept</del>;
  template &lt;class Clock, class Duration&gt;
    bool try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) <del>noexcept</del>;
  [...]
};
</pre></blockquote>
</li>

<li><p>Modify the class <tt>recursive_timed_mutex</tt> synopsis in <sref ref="[thread.timedmutex.recursive]"/> as indicated:</p>

<blockquote><pre>
class recursive_timed_mutex {
public:
  [...]
  template &lt;class Rep, class Period&gt;
    bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) <del>noexcept</del>;
  template &lt;class Clock, class Duration&gt;
    bool try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) <del>noexcept</del>;
  [...]
};
</pre></blockquote>
</li>

<li><p>Modify the class template <tt>unique_lock</tt> synopsis in <sref ref="[thread.lock.unique]"/> as indicated.
This edit seems also to fix an inconsistency between the timed waiting c'tors and the timed waiting member functions (see
next bullet):</p>

<blockquote><pre>
template &lt;class Mutex&gt;
class unique_lock {
public:
  [...]
  template &lt;class Clock, class Duration&gt;
    unique_lock(mutex_type&amp; m, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) <del>noexcept</del>;
  template &lt;class Rep, class Period&gt;
    unique_lock(mutex_type&amp; m, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) <del>noexcept</del>;
  [...]
};
</pre></blockquote>
</li>

<li><p>Modify the constructor prototypes in <sref ref="[thread.lock.unique.cons]"/> before p. 14 and p. 17 and
re-add <i>Throws</i> elements as indicated.
This edit seems also to fix an inconsistency compared to the timed waiting member functions:</p>

<blockquote><pre>
template &lt;class Clock, class Duration&gt;
  unique_lock(mutex_type&amp; m, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) <del>noexcept</del>;
</pre><blockquote><p>
[...]
<p/>
16 <i>Postconditions</i>: <tt>pm == &amp;m</tt> and <tt>owns == res</tt>, where <tt>res</tt> is the value returned 
by the call to <tt>m.try_lock_until(abs_time)</tt>.
<p/>
<ins>?? <i>Throws</i>: Nothing unless the exception is thrown by <tt>m.try_lock_until(abs_time)</tt>.</ins>
</p></blockquote></blockquote>

<blockquote><pre>
template &lt;class Rep, class Period&gt;
  unique_lock(mutex_type&amp; m, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) <del>noexcept</del>;
</pre><blockquote><p>
[...]
<p/>
19 <i>Postconditions</i>: <tt>pm == &amp;m</tt> and <tt>owns == res</tt>, where <tt>res</tt> is the value returned 
by the call to <tt>m.try_lock_for(rel_time)</tt>.
<p/>
<ins>?? <i>Throws</i>: Nothing unless the exception is thrown by <tt>m.try_lock_for(rel_time)</tt>.</ins>
</p></blockquote></blockquote>
</li>

<li><p>Modify the time-related <i>Throws</i> elements in <sref ref="[thread.condition.condvar]"/>, p. 19, p. 25, p. 36 and add some
new <i>Throws</i> elements as indicated. The latter are needed to honor possible exceptions from predicates:</p>

<p>
[...]
</p>
<blockquote><pre>
template &lt;class Predicate&gt;
void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
</pre></blockquote>
<blockquote><p>
14 <i>Effects</i>:
</p><blockquote><pre>
while (!pred())
  wait(lock);
</pre></blockquote>
</blockquote>
<blockquote><p>
<ins>?? <i>Throws</i>: Any exception thrown by an operation of <tt>pred</tt> or as result of the remaining effects.</ins>
</p></blockquote>
<p>
[...]
</p>
<blockquote><p>
19 <i>Throws</i>: <ins>Any exception thrown by <tt>Clock::now()</tt> or by an operation of <tt>abs_time</tt>. [<i>Note</i>: Instantiations 
of time point types and clocks supplied by the implementation as specified in <sref ref="[time.clock]"/> do not throw exceptions. &mdash; 
<i>end note</i>] Otherwise</ins> <tt>system_error</tt> when an exception is required (30.2.2).
</p></blockquote>
<p>
[...]
</p>
<blockquote><p>
25 <i>Throws</i>: <ins>Any exception thrown by an operation of <tt>rel_time</tt>. [<i>Note</i>: Instantiations of duration types supplied 
by the implementation as specified in <sref ref="[time.clock]"/> do not throw exceptions. &mdash; <i>end note</i>] Otherwise</ins>
<tt>system_error</tt> when an exception is required (30.2.2).
</p></blockquote>

<p>
[...]
</p>

<blockquote><pre>
template &lt;class Clock, class Duration, class Predicate&gt;
bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred);
</pre></blockquote>
<blockquote><p>
27 <i>Effects</i>:
</p><blockquote><pre>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></blockquote>
</blockquote>
<blockquote><p>
28 <i>Returns</i>: <tt>pred()</tt>
</p></blockquote>
<blockquote><p>
29 [ <i>Note</i>: The returned value indicates whether the predicate evaluates to true regardless of whether the
timeout was triggered. &mdash; <i>end note</i> ]
</p></blockquote>
<blockquote><p>
<ins>?? <i>Throws</i>: Any exception thrown by an operation of <tt>pred</tt> or as result of the remaining effects.</ins>
</p></blockquote>

<blockquote><pre>
template &lt;class Rep, class Period, class Predicate&gt;
bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</pre></blockquote>
<p>
[...]
</p>

<blockquote><p>
31 <i>Effects</i>: as if
</p><blockquote><pre>
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
</pre></blockquote>
</blockquote>
<p>
[...]
</p>
<blockquote><p>
36 <i>Throws</i>: <ins>Any exception thrown by an operation of <tt>rel_time</tt> or <tt>pred</tt>. [<i>Note</i>: Instantiations of duration types supplied 
by the implementation as specified in <sref ref="[time.clock]"/> do not throw exceptions. &mdash; <i>end note</i>] Otherwise</ins>
<tt>system_error</tt> when an exception is required (30.2.2).
</p></blockquote>
</li>

<li><p>Modify the time-related <i>Throws</i> elements in <sref ref="[thread.condition.condvarany]"/>, p. 15, p. 20, p. 30 and add some
new <i>Throws</i> elements as indicated. The latter are needed to honor possible exceptions from predicates:</p>

<p>
[...]
</p>
<blockquote><pre>
template &lt;class Lock, class Predicate&gt;
void wait(Lock&amp; lock, Predicate pred);
</pre></blockquote>
<blockquote><p>
11 <i>Effects</i>:
</p><blockquote><pre>
while (!pred())
  wait(lock);
</pre></blockquote>
</blockquote>
<blockquote><p>
<ins>?? <i>Throws</i>: Any exception thrown by an operation of <tt>pred</tt> or as result of the remaining effects.</ins>
</p></blockquote>
<p>
[...]
</p>
<blockquote><p>
15 <i>Throws</i>: <ins>Any exception thrown by <tt>Clock::now()</tt> or by an operation of <tt>abs_time</tt>. [<i>Note</i>: Instantiations of 
time point types and clocks supplied by the implementation as specified in <sref ref="[time.clock]"/> do not throw exceptions. &mdash;
<i>end note</i>] Otherwise</ins> <tt>system_error</tt> when an exception is required (30.2.2).
</p></blockquote>
<p>
[...]
</p>
<blockquote><p>
20 <i>Throws</i>: <ins>Any exception thrown by an operation of <tt>rel_time</tt>. [<i>Note</i>: Instantiations of duration types supplied 
by the implementation as specified in <sref ref="[time.clock]"/> do not throw exceptions. &mdash; <i>end note</i>]. Otherwise</ins>
<tt>system_error</tt> when an exception is required (30.2.2).
</p></blockquote>
<p>
[...]
</p>

<blockquote><pre>
template &lt;class Lock, class Clock, class Duration, class Predicate&gt;
bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred);
</pre></blockquote>
<blockquote><p>
22 <i>Effects</i>:
</p><blockquote><pre>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></blockquote>
</blockquote>
<blockquote><p>
23 <i>Returns</i>: <tt>pred()</tt>
</p></blockquote>
<blockquote><p>
24 [ <i>Note</i>: The returned value indicates whether the predicate evaluates to true regardless of whether the
timeout was triggered. &mdash; <i>end note</i> ]
</p></blockquote>
<blockquote><p>
<ins>?? <i>Throws</i>: Any exception thrown by an operation of <tt>pred</tt> or as result of the remaining effects.</ins>
</p></blockquote>

<blockquote><pre>
template &lt;class Lock, class Rep, class Period, class Predicate&gt;
bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</pre></blockquote>
<blockquote><p>
25 <i>Effects</i>: as if
</p><blockquote><pre>
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
</pre></blockquote>
</blockquote>

<p>
[...]
</p>
<blockquote><p>
30 <i>Throws</i>: <ins>Any exception thrown by an operation of <tt>rel_time</tt> or <tt>pred</tt>. [<i>Note</i>: Instantiations 
of duration types supplied by the implementation as specified in <sref ref="[time.clock]"/> do not throw exceptions. &mdash; 
<i>end note</i>] Otherwise</ins> <tt>system_error</tt> when an exception is required (30.2.2).
</p></blockquote>
</li>
</ol>

</resolution>

</issue>
