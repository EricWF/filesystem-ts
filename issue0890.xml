<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="890" status="WP">
<title>Improving <tt>&lt;system_error&gt;</tt> initialization</title>
<section><sref ref="[syserr.errcat]"/></section>
<submitter>Beman Dawes</submitter>
<date>14 Sep 2008</date>

<discussion>
<p>
The <tt>static const error_category</tt> objects <tt>generic_category</tt> and
<tt>system_category</tt> in header <tt>&lt;system_error&gt;</tt> are currently declared:
</p>

<blockquote><pre>
const error_category&amp; get_generic_category();
const error_category&amp; get_system_category();

static const error_category&amp; generic_category = get_generic_category();
static const error_category&amp; system_category = get_system_category();
</pre></blockquote>

<p>
This formulation has several problems:
</p>

<ul>
<li>
Implementation details are exposed, since initialization is specified in
the interface. This over-constrains implementations without offsetting
user benefits. The form of initialization specified may be less than
maximally efficient on some platforms.
</li>
<li>
Use of the objects is more expensive in terms of number of machine level
instructions. See <i>Implementation experience</i> below.
</li>
<li>
Depending on the compiler, some cost may be incurred by each translation unit
that includes the header, even if the objects are not used. This is a
common scenario in user code, since the header is included by other
standard library headers. It should be mentioned that at least one
compilers is able to optimize this cost away, however.
</li>
</ul>

<p>
IO streams uses a somewhat different formulation for iostream_category, but 
still suffer much the same problems.
</p>

<p>
The original plan was to eliminate these problems by applying the C++0x
<tt>constexpr</tt> feature. See LWG issue <iref ref="832"/>. However, that approach turned out
to be unimplementable, since it would require a <tt>constexpr</tt> object of a
class with virtual functions, and that is not allowed by the core
language.
</p>

<p>
The proposed resolution was developed as an alternative. It mitigates the above 
problems by removing initialization from the visible interface, allowing 
implementations flexibility.
</p>

<p>
<b>Implementation experience:</b>
</p>

<p>
Prototype implementations of the current WP interface and proposed
resolution interface were tested with recent Codegear, GCC, Intel, and Microsoft 
compilers on Windows. The code generated by the Microsoft compiler was studied 
at length; the WP and proposal versions generated very similar code. For both versions 
the compiler did make use of static
initialization; apparently the compiler applied an implicit <tt>constexpr</tt>
where useful, even in cases where <tt>constexpr</tt> would not be permitted by
the language!
</p>

<p>
<b>Acknowledgements:</b>
</p>

<p>
Martin Sebor, Chris Kohlhoff, and John Lakos provided useful ideas and comments on initialization issues.
</p>

<note>
San Francisco:
</note>

<blockquote>
<p>
Martin: prefers not to create more file-scope static objects, and would
like to see <tt>get_*</tt> functions instead.
</p>
</blockquote>


<p><i>[Pre-Summit:]</i></p>

<blockquote>


<p>
Beman: The proposed resolution has been reworked to remove the file-scope 
static objects, per Martin&#39;s suggestions. The <tt>get_</tt> prefix has been 
eliminated from the function names as no longer necessary and to conform with 
standard library naming practice.
</p>

</blockquote>

<note>
Post Summit:
</note>

<blockquote><p>
Agreement that this is wise and essential, text provided works and has
been implemented. Seems to be widespread consensus. Move to Tentative Ready.
</p></blockquote>

</discussion>

<resolution>

<p>Change <sref ref="[value.error.codes]"/> Value of error codes as indicated:</p>
<blockquote>
 <p>Certain functions in the C++ standard library report errors via a 
 <tt>std::error_code</tt> (19.4.2.2) object. That object's <tt>category()</tt> member shall 
 return <del>a reference to</del> <code>std::system_category</code><tt><ins><code>()</code></ins></tt> for errors originating from the 
 operating system, or a reference to an implementation-defined error_category 
 object for errors originating elsewhere. The implementation shall define the 
 possible values of value() for each of these error categories. [<i>Example:</i> For 
 operating systems that are based on POSIX, implementations are encouraged to 
 define the <code>std::system_category</code><tt><ins><code>()</code></ins></tt> values as identical to the POSIX <tt>errno</tt> values, 
 with additional values as defined by the operating system's documentation. 
 Implementations for operating systems that are not based on POSIX are 
 encouraged to define values identical to the operating system's values. For 
 errors that do not originate from the operating system, the implementation may 
 provide enums for the associated values --<i>end example</i>]</p>
</blockquote>

<p>
Change <sref ref="[syserr.errcat.overview]"/> Class <tt>error_category</tt> overview
<tt>error_category</tt> synopsis as indicated:
</p>

<blockquote>
<pre>
const error_category&amp; <del>get_</del>generic_category();
const error_category&amp; <del>get_</del>system_category();

<del>static storage-class-specifier const error_category&amp; generic_category = get_generic_category();
static storage-class-specifier const error_category&amp; system_category = get_system_category();</del>
</pre>
</blockquote>

<p>
Change <sref ref="[syserr.errcat.objects]"/> Error category objects as indicated:
</p>

<blockquote>
<pre>const error_category&amp; <del>get_</del>generic_category();
</pre>

<blockquote>

<p>
<i>Returns:</i> A reference to an object of a type derived from class <tt>error_category</tt>.
</p>

<p>
<i>Remarks:</i> The object's <tt>default_error_condition</tt> and <tt>equivalent</tt> virtual
functions shall behave as specified for the class <tt>error_category</tt>. The
object's <tt>name</tt> virtual function shall return a pointer to the string
<tt>"GENERIC"</tt>.
</p>
</blockquote>

<pre>
const error_category&amp; <del>get_</del>system_category();
</pre>

<blockquote>
<p>
<i>Returns:</i> A reference to an object of a type derived from class <tt>error_category</tt>.
</p>

<p>
<i>Remarks:</i> The object's <tt>equivalent</tt> virtual functions shall behave as
specified for class <tt>error_category</tt>. The object's <tt>name</tt> virtual function
shall return a pointer to the string <tt>"system"</tt>. The object's
<tt>default_error_condition</tt> virtual function shall behave as follows:
</p>
<blockquote><p>
If the argument <tt>ev</tt> corresponds to a POSIX <tt>errno</tt> value <tt>posv</tt>, the function
shall return <tt>error_condition(posv, generic_category<ins>()</ins>)</tt>. Otherwise, the
function shall return <tt>error_condition(ev, system_category<ins>()</ins>)</tt>. What
constitutes correspondence for any given operating system is
unspecified. [<i>Note:</i> The number of potential system error codes is large
and unbounded, and some may not correspond to any POSIX <tt>errno</tt> value.
Thus implementations are given latitude in determining correspondence.
&mdash; <i>end note</i>]
</p></blockquote>
</blockquote>

</blockquote>

<p>Change <sref ref="[syserr.errcode.constructors]"/> Class <tt>error_code</tt> constructors 
as indicated:</p>
<blockquote>
 <pre>error_code();</pre>
 <blockquote>
 <p><i>Effects:</i> Constructs an object of type error_code.</p>
 <p><i>Postconditions:</i> <code>val_ == 0 </code>and <code>cat_ == &amp;system_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change <sref ref="[syserr.errcode.modifiers]"/> Class <tt>error_code</tt> modifiers as 
indicated:</p>
<blockquote>
 <pre>void clear();</pre>
 <blockquote>
 <p>Postconditions: <code>value() == 0</code> and <code>category() == 
 system_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change <sref ref="[syserr.errcode.nonmembers]"/> Class <tt>error_code</tt> non-member 
functions as indicated:</p>
<blockquote>
 <pre>error_code make_error_code(errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <code>error_code(static_cast&lt;int&gt;(e), generic_category</code><tt><ins>()</ins></tt><code>)</code>.</p>
 </blockquote>
</blockquote>
<p>Change <sref ref="[syserr.errcondition.constructors]"/> Class <tt>error_condition</tt> 
constructors as indicated:</p>
<blockquote>
 <pre>error_condition();</pre>
 <blockquote>
 <p><i>Effects:</i> Constructs an object of type <code>error_condition</code>.</p>
 <p><i>Postconditions:</i> <code>val_ == 0</code> and <code>cat_ == &amp;generic_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change <sref ref="[syserr.errcondition.modifiers]"/> Class <tt>error_condition</tt> 
modifiers as indicated:</p>
<blockquote>
 <pre>void clear();</pre>
 <blockquote>
 <p><i>Postconditions:</i> <code>value() == 0</code> and <code>category() == 
 generic_category</code><tt><ins>()</ins></tt>.</p>
 </blockquote>
</blockquote>
<p>Change <sref ref="[syserr.errcondition.nonmembers]"/> Class <tt>error_condition</tt> 
non-member functions as indicated:</p>
<blockquote>
 <pre>error_condition make_error_condition(errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <tt>error_condition(static_cast&lt;int&gt;(e), generic_category<ins>()</ins>)</tt>.</p>
 </blockquote>
</blockquote>
 <p>Change <sref ref="[iostreams.base]"/> Iostreams base classes, Header <tt>&lt;ios&gt;</tt> 
 synopsis as indicated:</p>
<blockquote>
 <pre>concept_map ErrorCodeEnum&lt;io_errc&gt; { };
error_code make_error_code(io_errc e);
error_condition make_error_condition(io_errc e);
<del>storage-class-specifier</del> const error_category&amp; iostream_category<ins>()</ins>;</pre>
</blockquote>
<p>Change <sref ref="[ios::failure]"/> Class ios_base::failure, paragraph 2 as 
indicated:</p>
<blockquote>
<p>When throwing <tt>ios_base::failure</tt> exceptions, implementations should provide 
values of <tt>ec</tt> that identify the specific reason for the failure. [ <i>Note</i>: Errors 
arising from the operating system would typically be reported as <tt>
system_category</tt><tt><ins>()</ins></tt> errors with an error value of the 
error number reported by the operating system. Errors arising from within the 
stream library would typically be reported as <tt>error_code(io_errc::stream, 
iostream_category<ins>()</ins>)</tt>. &mdash; <i>end note</i> ]</p>
</blockquote>
<p>Change <sref ref="[error.reporting]"/> Error reporting as indicated:</p>
<blockquote>
 <pre>error_code make_error_code(io_errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <code>error_code(static_cast&lt;int&gt;(e), iostream_category</code><ins>()</ins><code>)</code>.</p>
 </blockquote>
 <pre>error_condition make_error_condition(io_errc e);</pre>
 <blockquote>
 <p><i>Returns:</i> <code>error_condition(static_cast&lt;int&gt;(e), 
 iostream_category</code><ins>()</ins><code>)</code>.</p>
 </blockquote>
 <pre><del>storage-class-specifier</del> const error_category&amp; iostream_category<ins>()</ins>;</pre>
 <blockquote>
 <del><p>The implementation shall initialize iostream_category. Its storage-class-specifier 
 may be static or extern. It is unspecified whether initialization is static 
 or dynamic (3.6.2). If initialization is dynamic, it shall occur before 
 completion of the dynamic initialization of the first translation unit 
 dynamically initialized that includes header &lt;system_error&gt;.</p></del>
<p>
<ins><i>Returns:</i> A reference to an object of a type derived from class <tt>error_category</tt>.</ins>
</p>
<p><i>Remarks:</i> The object's default_error_condition and equivalent virtual functions shall 
behave as specified for the class error_category. The object's name virtual 
function shall return a pointer to the string &quot;iostream&quot;.</p>
 </blockquote>
</blockquote>


</resolution>

</issue>
