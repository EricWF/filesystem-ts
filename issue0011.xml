<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="11" status="New">
<title>[PDTS] Lack of relative() operation function</title>
<section><sref ref="6 & 15"/></section>
<submitter>GB-1</submitter>
<date>20 Jan 2014</date>

<discussion>
<p>There is no relative() 
operation, to complement both absolute() and canonical()</p>
<p>

The TS introduces relative paths. </p>
<ul>
  <li>
    <p>

      They are defined in section 4.18
      relative path [fs.def.relative-path]
    </p> </li>
  <li>
    <p>

      A decomposition method

      relative_path()
      is described in section 8.4.9 path decomposition [path.decompose]
    </p> 
  </li>
  <li>
  <p>
  
  Two query methods to determine if a path 
  either 
  has_relative_path() 
  or 
  is_relative() 
  described in 8.4.10 path query [path.query] </p>
</li>
</ul>
<p>

However there is no way to create a relative path as a path relative to another. 
Methods are provided to create absolute and canonical paths.</p>
<p>

In section 15.1 Absolute [fs.op.absolute]:</p>
<p>

path absolute(const 
path&amp; 
p,
const 
path&amp; 
base=current_path());</p>
<p>

and in section 15.2 Canonical [fs.op.canonical]</p>
<p>

path canonical(const 
path&amp; 
p,
const 
path&amp; 
base = 
current_path());</p>
<p>

path canonical(const 
path&amp; 
p, 
error_code&amp; 
ec);</p>
<p>

path canonical(const 
path&amp; 
p,
const 
path&amp; 
base, 
error_code&amp; 
ec);</p>
<p>
By providing a 
operations to achieve absolute and canonical paths there is no impediment to 
providing a similar operation 

relative() 
that
attempts to return a new path relative to 
some base path.</p>
<p>

For example:</p>
<p>

path relative(const 
path&amp; 
p,
const 
path&amp; 
to = 
current_path());</p>
<p>

path relative(const 
path&amp; 
p, 
error_code&amp; 
ec);</p>
<p>

path relative(const 
path&amp; 
p,
const 
path&amp; 
to, 
error_code&amp; 
ec);</p>
<p>

This would return a 
path, if possible, that is relative to 

to. 
The implementation can make use of 

absolute() 
and 
canonical() 
to determine the relative path, if it exists.</p>
<p>

The File System TS is 
based on the 
<a HREF="http://www.boost.org/doc/libs/1_55_0/libs/filesystem/doc/index.htm">

<u>&#8203;</u></a><a HREF="http://www.boost.org/doc/libs/1_55_0/libs/filesystem/doc/index.htm">boost::filesystem 
library</a> and it too suffers from this anomaly. There are open tickets for 
this in 
<a HREF="https://svn.boost.org/">

<u>&#8203;</u></a><a HREF="https://svn.boost.org/">Boost 
Trac</a>:</p>
<ul>
  <li>
  <p>
  
  <a HREF="https://svn.boost.org/trac/boost/ticket/5897">
  <u>&#8203;</u></a><a HREF="https://svn.boost.org/trac/boost/ticket/5897">#5897 
  Make path relative function</a>
  </p>
</li>
  <li>
  <p>
  
  <a HREF="https://svn.boost.org/trac/boost/ticket/1976">
  <u>&#8203;</u></a><a HREF="https://svn.boost.org/trac/boost/ticket/1976">#1976 
  Inverse function for complete</a>
  </p>
</li>
</ul>
<p>

and it is the subject of several posts on StackOverflow for example:</p>
<ul>
  <li>
  <p>
  
  <a HREF="http://stackoverflow.com/questions/10167382/boostfilesystem-get-relative-path">
  <u>&#8203;</u></a><a HREF="http://stackoverflow.com/questions/10167382/boostfilesystem-get-relative-path">http://stackoverflow.com/questions/10167382/boostfilesystem-get-relative-path</a>
  </p>
</li>
  <li>
  <p>
  
  <a HREF="http://stackoverflow.com/questions/5772992/get-relative-path-from-two-absolute-paths">
  <u>&#8203;</u></a><a HREF="http://stackoverflow.com/questions/5772992/get-relative-path-from-two-absolute-paths">http://stackoverflow.com/questions/5772992/get-relative-path-from-two-absolute-paths</a>
  </p>
</li>
</ul>
<p>

Other languages typically provide a similar function. For example python 
provides:</p>
<p>

os.path.relpath(path[, 
start])</p>
<p>

Return a relative 
filepath to 
path 
either from the current directory or from an optional 

start 
directory. This is a path computation: the filesystem is not accessed to confirm 
the existence or nature of 
path 
or 
start.
start 
defaults to 
os.curdir.</p>

  <p>
    <i>[2014-02-07: Beman Dawes comments:]</i>
  </p>

<p>A <code>relative()</code> function is useful and much requested.
I've seen such a function provided by users and have written it myself in app code.
It is one of those things I've been meaning to do for years, and have just never gotten around to.</p>

  <p>That said, my mild perference is to treat this as "NAD, Future" for File System TS1,
  but treat it as a priority for TS2.</p>  


</discussion>

<resolution>
<p>Modify section:
6 Header &lt;filesystem&gt; synopsis [fs.filesystem.synopsis]
by adding the operational functions after canonical</p>

<pre>path relative(const path& p, const path& to = current_path());
path relative(const path& p, error_code& ec);
path relative(const path& p, const path& to, error_code& ec);</pre>

<p>Insert the section:</p>

15.3 Relative [fs.op.relative]
<pre>
path relative(const path& p, const path& to = current_path());
path relative(const path& p, error_code& ec);
path relative(const path& p, const path& to, error_code& ec);</pre>

<p>Overview: Return a relative path of p to the current directory or from an optional to path.</p>
<p>Returns: A relative path such that canonical(to)/relative(p,to) == canonical(p),
otherwise path(). If canonical(to) == canonical(p) the path path(".") is returned. For the
overload without a to argument, to is current_path(). Signatures with argument ec return
path() if an error occurs.</p>
<p>
Throws: As specified in Error reporting.</p>
<p>

Remarks: !exists(p) or !exists(to) or !is_directory(to) is an error.
and bump all following sections up by 0.1. Update the contents and any cross-references
accordingly.

</p>
<p>
Question: Should Returns be specified in terms of equivalence? For example:
equivalent( canonical(to)/relative(p,to), canonical(p) )
</p>
<p>

Question: Should canonical(to) == canonical(p) return path(".") or path()? Why?
</p>
<p>

Question: Should to be spelt start?</p></resolution>

</issue>
